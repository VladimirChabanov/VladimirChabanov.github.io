[TOC]

#### <span>36</span>. Класс Точка на плоскости

<div id="testing" style="background-size: 40px 40px; background-image: -moz-linear-gradient(135deg, rgba(255, 255, 255, .05) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .05) 50%, rgba(255, 255, 255, .05) 75%, transparent 75%, transparent); background-image: -webkit-linear-gradient(135deg, rgba(255, 255, 255, .05) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .05) 50%, rgba(255, 255, 255, .05) 75%, transparent 75%, transparent); background-image: linear-gradient(135deg, rgba(255, 255, 255, .05) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .05) 50%, rgba(255, 255, 255, .05) 75%, transparent 75%, transparent); box-shadow: 0 0 8px rgba(0,0,0,.3); width: 100%; margin: 0 auto; padding:15px; background-color: #4ea5cd; border-left:7px #3b8eb5 solid;">
<a href="#" style="text-decoration: none; font:16px 'Open Sans'; font-weight:600; color:#f4f0fc;">Ссылка для тренировки</a> (скоро)
</div>
***С++***

Создайте класс `Point` реализующий идею [точки](https://ru.wikipedia.org/wiki/Точка_(геометрия)) на плоскости. Внутренняя реализация класса на ваше усмотрение.

В качестве обязательных членов должны присутствовать:

1. Конструкторы:
   - Конструктор с тремя параметрами `a1` и `a2` типа `double` и `coord_system` типа перечисление состоящее из двух значений: [`Cartesian`](https://ru.wikipedia.org/wiki/Прямоугольная_система_координат) и [`Polar`](https://ru.wikipedia.org/wiki/Полярная_система_координат). Если третий параметр задан как `Cartesian`, то параметры `a1` и `a2` являются координатами `x` и `y` декартовой системы координат, если третий параметр задан как `Polar`, то `a1` и `a2` это `r` и $\varphi$ полярной системы координат соответственно ($\varphi$ везде задаётся в радианах). Параметр `coord_system` имеет значение по умолчанию `Cartesian`, а `a1` и `a2` по умолчанию нули.
2. Деструкторы. Т.к. класс динамически нечего не создаёт деструктор можно не объявлять.
3. Операторы `==` и `!=`. Сравнивает два объекта класса `Point` на равенство/не равенство, при этом не играет роли в какой системе координат задавались координаты точки при создании. Если отклонение по каждой координате не превышает 10<sup>-10</sup>, то считается что это одна и та же точка. 
4. Оператор `<<`. Выводит координаты точки в поток в виде строки в формате: "(X,Y)", где X и Y заменяются на значение координат точки `x` и `y` в декартовой системе координат.
5. Оператор `>>`. Считывает координаты точки из потока в виде строки в формате: "(X,Y)", где X и Y координаты точки `x` и `y` в декартовой системе координат.
6. Методы `get_x` и `get_y` возвращающие координаты точки в декартовой системе координат;
7. Методы `get_r` и `get_phi` возвращающие координаты точки в полярной системе координат;
8. Методы `set_x` и `set_y` устанавливающие новое значение соответствующей координаты точки в декартовой системе координат;
9. Методы `set_r` и `set_phi` устанавливающие новое значение  соответствующей координаты точки в полярной системе координат;

Используйте код представленный ниже и [этот файл](./resources/files/task36/data.txt) для проверки правильности реализации класса и операторов. Класс можно описать тут же или подключить как отдельный файл (он пригодится в следующем задании).

```c++
#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
  
const auto PI = 3.141592653589793;
  
class Point;
// Ваш код тут
  
int main() {
	std::vector<Point> original;
	std::ifstream fin("data.txt");
	if (!fin.is_open()) { 
		std::cout << "Can't open file" << std::endl;
		return 1; 
	} else {
		while (!fin.eof()) {
			Point p;
			fin >> p;
			fin.ignore(2); // Точки разделены двумя символами ", "
			original.push_back(p);
		}
		fin.close();
	}
  
	std::vector<Point> simulacrum(original);
	for (auto& p : simulacrum) {
		std::cout << p;
		p.set_x(p.get_x() + 10);
		p.set_phi(p.get_phi() + 180*PI/180);
		p.set_y(-p.get_y());
		p.set_x(-p.get_x() - 10);
		std::cout << p << std::endl;
	}
  
	if (std::equal(original.begin(), original.end(), simulacrum.begin()))
		std::cout << "\nIt works!\n";
	else 
		std::cout << "\nIt not works!\n";
}
```

***Python***

По аналогии с заданием для **С++** реализуйте класс `Point`.

В качестве обязательных членов должны присутствовать:

1. Метод `__init__`. Кроме `self` должен принимать ещё три параметра: `a1` и `a2` и `coord_system`:
   1. Если параметр `a1` - это строка, то остальные параметры игнорируются, а сама строка парсится исходя из того, что она в формате: "(X,Y)", где X и Y вещественные координаты точки `x` и `y` в декартовой системе координат.
   2. Если параметр `a1` - это число, то смотрим на параметр `coord_system`. Он может принимать да значения: [`Cartesian`](https://ru.wikipedia.org/wiki/Прямоугольная_система_координат) и [`Polar`](https://ru.wikipedia.org/wiki/Полярная_система_координат). Если он задан как `Cartesian`, то параметры `a1` и `a2` являются координатами `x` и `y` декартовой системы координат, если `coord_system` задан как `Polar`, то `a1` и `a2` это `r` и $\varphi$ полярной системы координат соответственно ($\varphi$ везде задаётся в радианах). По умолчанию`coord_system` задан как `Cartesian`, а `a1` и `a2` по умолчанию нули.
2. Финализатор. Можно не объявлять.
3. Операторы `==` (метод `__eq__`) и `!= ` (метод `__ne__`). Сравнивает два объекта класса `Point` на равенство/не равенство, при этом не играет роли в какой системе координат задавались координаты точки при создании. Если отклонение по каждой координате не превышает 10<sup>-10</sup>, то считается что это одна и та же точка. 
4. Методы `__repr__` и `__str__`. Преобразуют объект класса `Point` в строку в формате: "(X,Y)", где X и Y заменяются на значение координат точки `x` и `y` в декартовой системе координат.
6. Методы `get_x` и `get_y` возвращающие координаты точки в декартовой системе координат;
7. Методы `get_r` и `get_phi` возвращающие координаты точки в полярной системе координат;
8. Методы `set_x` и `set_y` устанавливающие новое значение соответствующей координаты точки в декартовой системе координат;
9. Методы `set_r` и `set_phi` устанавливающие новое значение  соответствующей координаты точки в полярной системе координат;

Используйте код представленный ниже и [этот файл](./resources/files/task36/data.txt) для проверки правильности реализации класса и операторов. Класс можно описать тут же или подключить как отдельный файл (он пригодится в следующем задании).

```python
import math
import copy
  
class Point:
    pass # Ваш код здесь
  
  
with open('data.txt') as fin:
    original = [Point(p) for p in fin.readline().split(', ')]
  
simulacrum = copy.deepcopy(original)
for p in simulacrum:
    print(p, end='')
    p.set_x(p.get_x() + 10)
    p.set_phi(p.get_phi() + 180*math.pi/180)
    p.set_y(-p.get_y())
    p.set_x(-p.get_x() - 10)
    print(p)
  
print('\nIt works!\n' if simulacrum == original else '\nIt not works!\n')
```

**Формат ввода**  
[Файл с данными](./resources/files/task36/data.txt) в формате: набор Точек разделённые двумя символами: запятая и пробел. Каждая точка задана в ПДСК в формате: открывающая круглая скобка, координата X, запятая, координата Y, закрывающая круглая скобка. Точки образуют [фигуру](https://www.desmos.com/calculator/pylclig6jz).

**Формат вывода**  
Вывод должен заканчиваться на "It works!",  что свидетельствует о том, что класс написан правильно. Если вывод заканчивается на "It not works!", значите в классе есть ошибки.



#### <span>37</span>. Класс Точка на плоскости

<div id="testing" style="background-size: 40px 40px; background-image: -moz-linear-gradient(135deg, rgba(255, 255, 255, .05) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .05) 50%, rgba(255, 255, 255, .05) 75%, transparent 75%, transparent); background-image: -webkit-linear-gradient(135deg, rgba(255, 255, 255, .05) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .05) 50%, rgba(255, 255, 255, .05) 75%, transparent 75%, transparent); background-image: linear-gradient(135deg, rgba(255, 255, 255, .05) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .05) 50%, rgba(255, 255, 255, .05) 75%, transparent 75%, transparent); box-shadow: 0 0 8px rgba(0,0,0,.3); width: 100%; margin: 0 auto; padding:15px; background-color: #4ea5cd; border-left:7px #3b8eb5 solid;">
<a href="#" style="text-decoration: none; font:16px 'Open Sans'; font-weight:600; color:#f4f0fc;">Ссылка для тренировки</a> (скоро)
</div>
***С++***

Создайте класс `Point` реализующий идею [точки](https://ru.wikipedia.org/wiki/Точка_(геометрия)) на плоскости. Внутренняя реализация класса на ваше усмотрение.

В качестве обязательных членов должны присутствовать:

1. Конструкторы:
   - Конструктор с тремя параметрами `a1` и `a2` типа `double` и `coord_system` типа перечисление состоящее из двух значений: [`Cartesian`](https://ru.wikipedia.org/wiki/Прямоугольная_система_координат) и [`Polar`](https://ru.wikipedia.org/wiki/Полярная_система_координат). Если третий параметр задан как `Cartesian`, то параметры `a1` и `a2` являются координатами `x` и `y` декартовой системы координат, если третий параметр задан как `Polar`, то `a1` и `a2` это `r` и $\varphi$ полярной системы координат соответственно ($\varphi$ везде задаётся в радианах). Параметр `coord_system` имеет значение по умолчанию `Cartesian`, а `a1` и `a2` по умолчанию нули.
2. Деструкторы. Т.к. класс динамически нечего не создаёт деструктор можно не объявлять.
3. Операторы `==` и `!=`. Сравнивает два объекта класса `Point` на равенство/не равенство, при этом не играет роли в какой системе координат задавались координаты точки при создании. Если отклонение по каждой координате не превышает 10<sup>-10</sup>, то считается что это одна и та же точка. 
4. Оператор `<<`. Выводит координаты точки в поток в виде строки в формате: "(X,Y)", где X и Y заменяются на значение координат точки `x` и `y` в декартовой системе координат.
5. Оператор `>>`. Считывает координаты точки из потока в виде строки в формате: "(X,Y)", где X и Y координаты точки `x` и `y` в декартовой системе координат.
6. Методы `get_x` и `get_y` возвращающие координаты точки в декартовой системе координат;
7. Методы `get_r` и `get_phi` возвращающие координаты точки в полярной системе координат;
8. Методы `set_x` и `set_y` устанавливающие новое значение соответствующей координаты точки в декартовой системе координат;
9. Методы `set_r` и `set_phi` устанавливающие новое значение  соответствующей координаты точки в полярной системе координат;

Используйте код представленный ниже и [этот файл](./resources/files/task36/data.txt) для проверки правильности реализации класса и операторов. Класс можно описать тут же или подключить как отдельный файл (он пригодится в следующем задании).

```c++
#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
  
const auto PI = 3.141592653589793;
  
class Point;
// Ваш код тут
  
int main() {
	std::vector<Point> original;
	std::ifstream fin("data.txt");
	if (!fin.is_open()) { 
		std::cout << "Can't open file" << std::endl;
		return 1; 
	} else {
		while (!fin.eof()) {
			Point p;
			fin >> p;
			fin.ignore(2); // Точки разделены двумя символами ", "
			original.push_back(p);
		}
		fin.close();
	}
  
	std::vector<Point> simulacrum(original);
	for (auto& p : simulacrum) {
		std::cout << p;
		p.set_x(p.get_x() + 10);
		p.set_phi(p.get_phi() + 180*PI/180);
		p.set_y(-p.get_y());
		p.set_x(-p.get_x() - 10);
		std::cout << p << std::endl;
	}
  
	if (std::equal(original.begin(), original.end(), simulacrum.begin()))
		std::cout << "\nIt works!\n";
	else 
		std::cout << "\nIt not works!\n";
}
```

***Python***

По аналогии с заданием для **С++** реализуйте класс `Point`.

В качестве обязательных членов должны присутствовать:

1. Метод `__init__`. Кроме `self` должен принимать ещё три параметра: `a1` и `a2` и `coord_system`:
   1. Если параметр `a1` - это строка, то остальные параметры игнорируются, а сама строка парсится исходя из того, что она в формате: "(X,Y)", где X и Y вещественные координаты точки `x` и `y` в декартовой системе координат.
   2. Если параметр `a1` - это число, то смотрим на параметр `coord_system`. Он может принимать да значения: [`Cartesian`](https://ru.wikipedia.org/wiki/Прямоугольная_система_координат) и [`Polar`](https://ru.wikipedia.org/wiki/Полярная_система_координат). Если он задан как `Cartesian`, то параметры `a1` и `a2` являются координатами `x` и `y` декартовой системы координат, если `coord_system` задан как `Polar`, то `a1` и `a2` это `r` и $\varphi$ полярной системы координат соответственно ($\varphi$ везде задаётся в радианах). По умолчанию`coord_system` задан как `Cartesian`, а `a1` и `a2` по умолчанию нули.
2. Финализатор. Можно не объявлять.
3. Операторы `==` (метод `__eq__`) и `!= ` (метод `__ne__`). Сравнивает два объекта класса `Point` на равенство/не равенство, при этом не играет роли в какой системе координат задавались координаты точки при создании. Если отклонение по каждой координате не превышает 10<sup>-10</sup>, то считается что это одна и та же точка. 
4. Методы `__repr__` и `__str__`. Преобразуют объект класса `Point` в строку в формате: "(X,Y)", где X и Y заменяются на значение координат точки `x` и `y` в декартовой системе координат.
6. Методы `get_x` и `get_y` возвращающие координаты точки в декартовой системе координат;
7. Методы `get_r` и `get_phi` возвращающие координаты точки в полярной системе координат;
8. Методы `set_x` и `set_y` устанавливающие новое значение соответствующей координаты точки в декартовой системе координат;
9. Методы `set_r` и `set_phi` устанавливающие новое значение  соответствующей координаты точки в полярной системе координат;

Используйте код представленный ниже и [этот файл](./resources/files/task36/data.txt) для проверки правильности реализации класса и операторов. Класс можно описать тут же или подключить как отдельный файл (он пригодится в следующем задании).

```python
import math
import copy
  
class Point:
    pass # Ваш код здесь
  
  
with open('data.txt') as fin:
    original = [Point(p) for p in fin.readline().split(', ')]
  
simulacrum = copy.deepcopy(original)
for p in simulacrum:
    print(p, end='')
    p.set_x(p.get_x() + 10)
    p.set_phi(p.get_phi() + 180*math.pi/180)
    p.set_y(-p.get_y())
    p.set_x(-p.get_x() - 10)
    print(p)
  
print('\nIt works!\n' if simulacrum == original else '\nIt not works!\n')
```

**Формат ввода**  
[Файл с данными](./resources/files/task36/data.txt) в формате: набор Точек разделённые двумя символами: запятая и пробел. Каждая точка задана в ПДСК в формате: открывающая круглая скобка, координата X, запятая, координата Y, закрывающая круглая скобка. Точки образуют [фигуру](https://www.desmos.com/calculator/pylclig6jz).

**Формат вывода**  
Вывод должен заканчиваться на "It works!",  что свидетельствует о том, что класс написан правильно. Если вывод заканчивается на "It not works!", значите в классе есть ошибки.
